<!DOCTYPE html>
<!-- _layouts/distill.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>How do you build 1/3 probability with a fair coin? | Amir  Joudaki</title>
    <meta name="author" content="Amir  Joudaki">
    <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://ajoudaki.github.io/blog/2024/cool-probability/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams',
        macros: {
          E: "{\\mathbb{E}}",
          P: "{\\mathbb{P}}",
          RR: "{\\bf R}",
          Expec: ["{\\left[ #1 \\right]}", 1],
          Prob: ["{\\mathbb{P}\\left( #1 \\right)}", 1],
          bold: ["{\\bf #1}", 1]}
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
    <!-- Page/Post style -->
    <style type="text/css">
      .fake-img {
  background: #bbb;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
  margin-bottom: 12px;
} .fake-img p {
  font-family: monospace;
  color: white;
  text-align: left;
  margin: 12px 0;
  text-align: center;
  font-size: 16px;
}

    </style>
  </head>

  <body>
<d-front-matter>
    <script async type="text/json">{
      "title": "How do you build 1/3 probability with a fair coin?",
      "description": "",
      "published": "February 14, 2024",
      "authors": [
        {
          "author": "Amir Joudaki",
          "authorURL": "",
          "affiliations": [
            {
              "name": "ETH, Zurich",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Amir </span>Joudaki</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">About</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/research/">Research</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">Repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">CV</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>How do you build 1/3 probability with a fair coin?</h1>
        <p></p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        

        <p>Here is the question:</p>

<blockquote>
  <p>Suppose you have a fair coin. Given integers $a$ and $b$ where $a&lt; b,$ can you devise a strategy that produces an event with a failure success of $a / b$? You may toss the coin as many times as you like.</p>
</blockquote>

<p>I found the question fascinating for a variety of reasons, But before I go on about various hints and my own thought processes. Please feel free to take as much time as you want before reading more on this problem.</p>

<p>My most immediate thought when thinking about the problem was, well, it is easy enough to build an event with $1/2, 1/4, … $ probability by simply tossing the coin several times and returning success if they all returned head, i.e., AND-ing these events. It also seems plausible we can construct events that are the sum of these values. Namely, $1/2 + 1/4= 3/4.$ Happy with my progress, I started to think of the simplest case that doesn’t fall into this pattern, and $1/3$ struck me as a good choice:</p>

<blockquote>
  <p>Given a fair coin, can you construct an event with $1/3$ probability?</p>
</blockquote>

<p>My vague idea is that the eventual solution must be a clever combination of a number of coin tosses that magically return $1/3$ probability. Despite my hopes, I started to note that most of my attempts ended with events that had a $a / 2^k$ probability of success, which is clearly a pattern that does not fit $1/3.$ My next idea (which, at the time, I thought was very clever) was that the magical combination of events must involve the Bayes rule. Suppose I can devise an event conditioned on another event where the ratios of the two probabilities are $1/3.$ All efforts in this direction were also blocked.</p>

<p>At this point, I was given a hint that there are roughly two approaches to solving this, and one of them involves approximating the event. This immediately kicked off an idea in my head: We can approximate any fractional number by an arbitrary precision in the binary base $\sum_{i=1}^\infty 2^{-k_i} $ where $k_1 &lt; k_2 &lt; \dots $ denote the non-zero binary indices.</p>

<p>Thus, if we’re happy with an “approximation” of $a/b, $ we can approximate the fraction as $a/b \approx \sum_{i=1}^m 2^{-k_i}.$  we can design the following scheme:  Let $E_i$ be an event with $2^{-k_i}$ probability of success, which we know how to construct. My next thought was that we could construct the main event as $E$ as the union of all events $E_i$’s $E = \bigcup_{i=1}^m E_i. $ My thinking was that $P(E) = \sum_{i=1}^m P(E_k) = \sum_{k=1}^m b_i 2^{-k} \approx a/b. $</p>

<p>I wrote down and implemented this idea in Python as follows.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span> 

<span class="c1"># fair coin
</span><span class="k">def</span> <span class="nf">coin</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1"># success of "k" coin tosses (1/2^k) probability
</span><span class="k">def</span> <span class="nf">coin_power</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">all</span><span class="p">([</span><span class="nf">coin</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>

<span class="c1"># approx a/b prob, B: bits of precision 
</span><span class="k">def</span> <span class="nf">approx_prob</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> 
    <span class="n">p_int</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">B</span><span class="p">)</span>
    <span class="n">p_bits</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">((</span><span class="n">p_int</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">B</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">non_zero_bits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">p_bits</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="nf">any</span><span class="p">([</span><span class="nf">coin_power</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">non_zero_bits</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_prob</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">100000</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sum</span><span class="p">([</span><span class="nf">f</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)])</span><span class="o">/</span><span class="n">num_samples</span>

<span class="nf">test_prob</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">approx_prob</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1"># result = 0.3121 ... 
</span></code></pre></div></div>
<p>To my surprise, the empirical likelihood of the event $0.3121…$ was slightly off from the expected one of $0.3333…$ no matter how many bits of precision and samples I used: A careful consideration reveals a flaw in my original reasoning for $P(E) = \sum_{i=1}^m P(E_i)$: In order to have probability of event equal to sum of individual events, they need to be disjoint: $P(E_i \wedge E_j ) = 0,\forall i\neq j,$ which is not the case if they are independent.</p>

<p>At this point, a hint suggested that <a href="https://en.wikipedia.org/wiki/Rejection_sampling" rel="external nofollow noopener" target="_blank">rejection sampling</a> might be a good way to solve this problem. To anyone who is familiar with this concept, this should immediately ring a bell: we can use the coin to define a uniform sampling over any set of power-of-two sizes: for a set of size $2^k$, we can toss $k$ coins and represent them jointly as a binary number $i = \sum_{j=0}^{k-1} i_j\cdot 2^k$ where $i \in [0,2^k-1]$ can be used as the index of the element in the set. We can assume WLOG that $2^k \ge b$. The magic of the rejection sample kicks in here: if we simply reject events $i &gt; b,$ in the remaining events, $i$ is a uniform sample over $0, …, b-1$, which is exactly what we want! However, we are left with some rejections. What should we do? Well, sample again! Here’s a python implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span> 

<span class="c1"># fair coin
</span><span class="k">def</span> <span class="nf">coin</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1"># success of "k" coin tosses (1/2^k) probability
</span><span class="k">def</span> <span class="nf">coin_power</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">all</span><span class="p">([</span><span class="nf">coin</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>

<span class="k">def</span> <span class="nf">rejection_sampling</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">([</span><span class="nf">int</span><span class="p">(</span><span class="nf">coin</span><span class="p">())</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> 

<span class="k">def</span> <span class="nf">test_prob</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sum</span><span class="p">([</span><span class="nf">f</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)])</span><span class="o">/</span><span class="n">num_samples</span>

<span class="nf">test_prob</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">rejection_sampling</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<p>This time, the result $0.333084… $ and the sample mean gets arbitrarily clsoe to $1/3$ as we increase the sample size.</p>

<p>Now, at this point, I was still left with one big daunting question: Is this the most sample-efficient way of going about this problem? In other words, how many random bits does this process consume? Let us assume that $a/b$ is already the smallest fraction ($a$ and $b$’s common denominator is $1$). Clearly, if $b$ is a power of $2$, $b = 2^k$, the process ends deterministically in one step and thus consumes $k = \lceil \log_2(b)\rceil $ random bits. Now, let us assume that $b$ is not a power of two, and we pick the $k$ corresponding to the smallest power of $2.$ In othre words, $b \in (2^{k-1},2^{k}).$ Now, considering that the event is not rejected with probability $b / 2^k,$ we can see that for any value of $b,$ we accept with $ b/ 2^k &gt; 2^{k-1} / 2^k = 1/2$ probability. Thus, on average, we use $2 \lceil \log_2(b)\rceil $ random bits for this process. We can also derive a high-probability bound by observing that the event of having more than $T$ rounds is upper bounded by $2^{-T-1} + 2^{-T-2} + \dots = 2^{-T}.$ Thus, we use at most $T \lceil \log_2(b)\rceil $ bits with $1 - 2^{-T}$ probability.</p>

<p>While this all seemed nice and good, I was still feeling a bit uneasy. More specifically, even for a simple event like $1/3,$ we can’t use a finite number of coin tosses to build this probability! In some sense, I was instinctually convinced that there is some clever way of constructing a finite number of coin tosses that lead to a $1/3$ probability. To my surprise (!), this seems to be impossible. So I sat about proving that it is genuinely impossible to use a <em>finite</em> number of random bits to construct an event with $1/3$ probability. As strong and daunting as that sentence might sound, the proof is extremely simple and straightforward.</p>

<p>In fact, any arbitrary and complex strategy that you take with random bits can be effectively mapped to a binary tree, with each node representing a random bit and the left (right) leaf of each node corresponding to an outcome of that bit (or coin toss). Finally, the leaves of this tree are the places where you designate an outcome (which could be True or False). Upon this abstraction, it is very easy to see that if our strategy guarantees a finite number of random bits or coin tosses, this implies a finite depth for this binary tree. Let’s say the depth of the tree is bounded by $k$. Therefore, probability of any leaf is of the form $2^{-l}$ where $0\le l\le k.$ Since any success leaf corresponds to a disjoint event with a negative power of two probability $2^{-k}$, the overall success probability equals the sum of negative powers of two. This has an immediate and very important revelation: the success probability of the root of the tree can be represented as a floating point in binary basis with at most k bits. For example, any event like $1/4, 3/8, 7/16$, and so on satisfies this. However, $1/3$ is clearly not representable on a binary basis with finite bits. This shows that the construction gave before was actually exactly tight in terms of its worst case rand bit complexity. This completes the proof that $1/3$ event cannot be produced if we only have a finite number of bits.</p>

<p>I thought this was a super cool and interesting observation from an almost ridiculously simple-sounding problem. I hope you enjoyed the read!</p>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/refs.bib"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;">
  <script>
    let giscusTheme = localStorage.getItem("theme");
    let giscusAttributes = {
        "src": "https://giscus.app/client.js",
        "data-repo": "alshedivat/al-folio",
        "data-repo-id": "MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==",
        "data-category": "Comments",
        "data-category-id": "DIC_kwDOA5PmLc4CTBt6",
        "data-mapping": "title",
        "data-strict": "1",
        "data-reactions-enabled": "1",
        "data-emit-metadata": "0",
        "data-input-position": "bottom",
        "data-theme": giscusTheme,
        "data-lang": "en",
        "crossorigin": "anonymous",
        "async": "",
    };


    let giscusScript = document.createElement("script");
    Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
    document.getElementById("giscus_thread").appendChild(giscusScript);
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a>
</noscript>
</div>
</div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2024 Amir  Joudaki. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  
</body>
</html>
